{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"offsetMil",
				"offsetMilliseconds"
			],
			[
				"UTC",
				"UTCMilliseconds"
			],
			[
				"off",
				"offsetMilliseconds"
			],
			[
				"mic",
				"micros"
			],
			[
				"di",
				"dieSize"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "// Electric Dice using MMA8452Q accelerometer */\n// ThingApp Imp Device Squirrel code */\n\n/////////////////////////////////////////////////\n// global constants and variables\nconst versionString = \"MMA8452Q Dice v00.01.2013-05-05a\"\nconst logIndent   = \"Device:_________>_________>_________>_________>_________>_________>_________>_________>_________>_________>_________>\"\nconst errorIndent = \"Device:#########!#########!#########!#########!#########!#########!#########!#########!#########!#########!#########!\" \nlogVerbosity <- 100 // higher numbers show more log messages\nerrorVerbosity <- 1000 // higher number shows more error messages\nimpeeID <- hardware.getimpeeid() // cache the impeeID FIXME: is this necessary for speed?\noffsetMilliseconds <- 42 // set later to milliseconds % 1000 when time() rolls over\n//DEPRECATED: wasActive <- true // stay alive on boot as if button was pressed or die moved/rolled\nconst sleepforTimeout = 60 // seconds with no activity before logging and dec idleCount\nconst sleepforDuration = 3300 // seconds to stay in deep sleep (wakeup is a reboot)\nconst idleCountdown = 6 // how many sleepforTimeout periods of inactivity before server.sleepfor\nidleCount <- idleCountdown // Current count of idleCountdown timer\nlastFaceValue <- \"boot\"\nconst accelChangeThresh = 500 // change in accel per sample to count as movement.  Units of milliGs\npollMMA8452QBusy <- false // guard against interrupt handler collisions FIXME: Is this necessary?  Debugging why I get no EA_BIT set error sometimes\n\n///////////////////////////////////////////////\n// constants for MMA8452Q i2c registers\n// the slave address for this device is set in hardware. Creating a variable to save it here is helpful.\n// The SparkFun breakout board defaults to 0x1D, set to 0x1C if SA0 jumper on the bottom of the board is set\nconst MMA8452Q_ADDR = 0x1D // A '<< 1' is needed.  I add the '<< 1' in the helper functions.\n//const MM8452Q_ADDR = 0x1C // Use this address if SA0 jumper is set. \nconst STATUS           = 0x00\n    const ZYXOW_BIT        = 0x7 // name_BIT == BIT position of name\n    const ZYXDR_BIT        = 0x3\nconst OUT_X_MSB        = 0x01\nconst SYSMOD           = 0x0B\n    const SYSMOD_STANDBY   = 0x00\n    const SYSMOD_WAKE      = 0x01\n    const SYSMOD_SLEEP     = 0x02\nconst INT_SOURCE       = 0x0C\n    const SRC_ASLP_BIT     = 0x7\n    const SRC_FF_MT_BIT    = 0x2\n    const SRC_DRDY_BIT     = 0x0\nconst WHO_AM_I         = 0x0D\n    const I_AM_MMA8452Q    = 0x2A // read addr WHO_AM_I, expect I_AM_MMA8452Q\nconst XYZ_DATA_CFG     = 0x0E\n    const FS_2G            = 0x00\n    const FS_4G            = 0x01\n    const FS_8G            = 0x02\n    const HPF_OUT_BIT      = 0x5\nconst HP_FILTER_CUTOFF = 0x0F\nconst FF_MT_CFG        = 0x15\n    const ELE_BIT          = 0x7\n    const OAE_BIT          = 0x6\n    const XYZEFE_BIT       = 0x3 // numBits == 3 (one each for XYZ)\n        const XYZEFE_ALL       = 0x07 // enable all 3 bits\nconst FF_MT_SRC        = 0x16\n    const EA_BIT           = 0x7\nconst FF_MT_THS        = 0x17\n    const DBCNTM_BIT       = 0x7\n    const THS_BIT          = 0x0 // numBits == 7\nconst FF_MT_COUNT      = 0x18\nconst ASLP_COUNT       = 0x29\nconst CTRL_REG1        = 0x2A\n    const ASLP_RATE_BIT    = 0x6 // numBits == 2\n        const ASLP_RATE_12p5HZ = 0x1\n        const ASLP_RATE_1p56HZ = 0x3\n    const DR_BIT           = 0x3 // numBits == 3\n        const DR_12p5HZ        = 0x5\n        const DR_1p56HZ        = 0x7\n    const LNOISE_BIT       = 0x2\n    const F_READ_BIT       = 0x1\n    const ACTIVE_BIT       = 0x0\nconst CTRL_REG2        = 0x2B\n    const ST_BIT           = 0x7\n    const RST_BIT          = 0x6\n    const SMODS_BIT        = 0x3 // numBits == 2\n    const SLPE_BIT         = 0x2\n    const MODS_BIT         = 0x0 // numBits == 2\n        const MODS_NORMAL      = 0x00\n        const MODS_LOW_POWER   = 0x03\nconst CTRL_REG3        = 0x2C\n    const WAKE_FF_MT_BIT   = 0x3\n    const IPOL_BIT         = 0x1\nconst CTRL_REG4        = 0x2D\n    const INT_EN_ASLP_BIT  = 0x7\n    const INT_EN_LNDPRT_BIT= 0x4\n    const INT_EN_FF_MT_BIT = 0x2\n    const INT_EN_DRDY_BIT  = 0x0\nconst CTRL_REG5        = 0x2E\n\n// helper variables for MMA8452Q. These are not const because they may have reason to change dynamically.\ni2c <- hardware.i2c89 // now can use i2c.read... instead of hardware.i2c89.read...\nvBatt <- hardware.pin5 // now we can use vBatt.read()\ni2cRetryPeriod <- 1.0 // seconds to wait before retrying a failed i2c operation\nmaxG <- FS_4G // what scale to get G readings\n\n///////////////////////////////////////////////\n//define functions\n\n// start with fairly generic functions\nfunction log(string, level) {\n    local indent = logIndent.slice(0, level / 10 + 7)\n    if (level <= logVerbosity)\n        server.log(indent + string)\n    if (level == 0)\n        server.show(string)\n}\n\nfunction error(string, level) {\n    local indent = errorIndent.slice(0, level / 10 + 7)\n    if (level <= errorVerbosity)\n        server.error(indent + string)\n}\n\nfunction timestamp() {\n    local t, m\n    t = time()\n    m = hardware.millis()\n    return format(\"%010.3f\", (t * 1.0) + ((m % 1000) - offsetMilliseconds) / 1000.0)\n        // return milliseconds since Unix epoch \n}\n\nfunction checkActivity() {\n// checkActivity re-schedules itself every sleepforTimeout\n// FIXME: checkActivity should be more generic\n    log(\"checkActivity() every \" + sleepforTimeout + \" secs.\", 200)\n    // let the agent know we are still alive\n    t <- timestamp()\n    agent.send(\n        \"dieEvent\",\n        {\n            \"keepAlive\": idleCount,\n            \"vBatt\": getVBatt(),\n            \"t\": t,\n// can't use priority until proper UTC is used            \".priority\": t\n        }\n    )\n    if (imp.getpowersave() == false) {\n        imp.setpowersave(true)\n        idleCount = idleCountdown // restart idle count down\n    } else {\n        if (idleCount == 0) {\n            idleCount = idleCountdown\n            log(\"No activity for \" + sleepforTimeout * idleCountdown + \" to \" + sleepforTimeout * (idleCountdown + 1) + \" secs.\\r\\nGoing to deepsleep for \" + (sleepforDuration / 60.0) + \" minutes.\", 10)\n            // Disable data ready interrupts.  Motion interrupts is left enabled in order to wake from sleep\n            // FIXME: this function should not know about MMA8452Q specifics\n            MMA8452QSetActive(0) // Can't write MMA8452Q until not active\n            writeReg(CTRL_REG4, writeBit(readReg(CTRL_REG4), INT_EN_DRDY_BIT, 0)) // turn off SRC_DRDY_BIT so it doesnt wake us up\n            writeReg(CTRL_REG4, writeBit(readReg(CTRL_REG4), INT_EN_ASLP_BIT, 0)) // turn off SRC_ASLP_BIT so it doesnt wake us up\n            // Make harder to wakeup. set Motion threshold to 32*0.063.  (16 * 0.063 == 1G)\n            //writeReg(FF_MT_THS, 32) // FIXME: this is a shortcut and assumes DBCNTM_BIT is 0\n            MMA8452QSetActive(1) // set to Active mode so tht SRC_FF_MT_BIT can wake us up\n            imp.onidle(function() { server.sleepfor(sleepforDuration) })  // go to deepsleep if no MMA8452Q interrupts for sleepforTimeout\n        } else {\n            idleCount -= 1\n        }\n    }\n    imp.wakeup(sleepforTimeout, checkActivity)\n} // checkActivity\n\n// now functions specific to devices that read i2c registers\n\nfunction readBitField(val, bitPosition, numBits){ // works for 8bit and registers\n    return (val >> bitPosition) & (0x00FF >> (8 - numBits))\n}\n\nfunction readBit(val, bitPosition) { return readBitField(val, bitPosition, 1) }\n\nfunction writeBitField(val, bitPosition, numBits, newVal) { // works for 8bit registers\n// newVal is not bounds checked\n    return (val & (((0x00FF >> (8 - numBits)) << bitPosition) ^ 0x00FF)) | (newVal << bitPosition)\n}\n\nfunction writeBit(val, bitPosition, newVal) { return writeBitField(val, bitPosition, 1, newVal) }\n\n// Read a single byte from addressToRead and return it as a byte.  (The '[0]' causes a byte to return)\nfunction readReg(addressToRead) {\n    return readSequentialRegs(addressToRead, 1)[0]\n}\n\n// Writes a single byte (dataToWrite) into addressToWrite.  Returns error code from i2c.write\n// Continue retry until success.  Caller does not need to check error code\nfunction writeReg(addressToWrite, dataToWrite) {\n    local err = null\n    while (err == null) {\n        err = i2c.write(MMA8452Q_ADDR << 1, format(\"%c%c\", addressToWrite, dataToWrite))\n        log(format(\"i2c.write addr=0x%02x data=0x%02x\", addressToWrite, dataToWrite), 150)\n        if (err == null) {\n            error(\"i2c.write of value \" + format(\"0x%02x\", dataToWrite) + \" to \" + format(\"0x%02x\", addressToWrite) + \" failed.\", 10)\n            imp.sleep(i2cRetryPeriod)\n            error(\"retry i2c.write\", 100)\n        }\n    }\n    return err\n}\n\n// Read numBytes sequentially, starting at addressToRead\n// Continue retry until success.  Caller does not need to check error code\nfunction readSequentialRegs(addressToRead, numBytes) {\n    local data = null\n    \n    while (data == null) {\n        data = i2c.read(MMA8452Q_ADDR << 1, format(\"%c\", addressToRead), numBytes)\n        if (data == null) {\n            error(\"i2c.read from \" + format(\"0x%02x\", addressToRead) + \" of \" + numBytes + \" byte\" + ((numBytes > 1) ? \"s\" : \"\") + \" failed.\", 10)\n            imp.sleep(i2cRetryPeriod)\n            error(\"retry i2c.read\", 100)\n        }\n    }\n    return data\n}\n\n// now functions unique to MMA8452Q\n\nfunction readAccelData() {\n    local rawData = null // x/y/z accel register data stored here, 3 bytes\n    local accelData = array(3)\n    local i\n    local val\n    \n    rawData = readSequentialRegs(OUT_X_MSB, 3)  // Read the three raw data registers into data array\n    foreach (i, val in rawData) {\n        accelData[i] = math.floor(1000.0 * ((val < 128 ? val : val - 256) / ((64 >> maxG) + 0.0)))\n            // HACK: in above calc maxG just happens to be (log2(full_scale) - 1)  see: const for FS_2G, FS_4G, FS_8G \n        //convert to signed integer milliGs\n    }\n    return accelData\n}\n\n// Reset the MMA8452Q\nfunction MMA8452QReset() {\n    local reg\n    \n    do {\n        reg = readReg(WHO_AM_I)  // Read WHO_AM_I register\n        if (reg == I_AM_MMA8452Q) {\n            log(\"Found MMA8452Q.  Sending RST command...\", 200)\n            break\n        } else {\n            error(\"Could not connect to MMA8452Q: WHO_AM_I reg == \" + format(\"0x%02x\", reg), 10)\n            imp.sleep(i2cRetryPeriod)\n        }\n    } while (true)\n    \n    // send reset command\n    writeReg(CTRL_REG2, writeBit(readReg(CTRL_REG2), RST_BIT, 1))\n\n    do {\n        reg = readReg(WHO_AM_I)  // Read WHO_AM_I register\n        if (reg == I_AM_MMA8452Q) {\n            log(\"MMA8452Q is online!\", 150)\n            break\n        } else {\n            error(\"Could not connect to MMA8452Q: WHO_AM_I reg == \" + format(\"0x%02x\", reg), 10)\n            imp.sleep(i2cRetryPeriod)\n        }\n    } while (true)\n}\n\nfunction MMA8452QSetActive(mode) {\n    // Sets the MMA8452Q active mode.\n    // 0 == STANDBY for changing registers\n    // 1 == ACTIVE for outputting data\n    writeReg(CTRL_REG1, writeBit(readReg(CTRL_REG1), ACTIVE_BIT, mode))\n}\n\nfunction initMMA8452Q() {\n// Initialize the MMA8452Q registers \n// See the many application notes for more info on setting all of these registers:\n// http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=MMA8452Q\n    local reg\n    \n    MMA8452QReset() // Sometimes imp card resets and MMA8452Q keeps power\n    // Must be in standby to change registers\n    // in STANDBY already after RESET//MMA8452QSetActive(0)\n\n    // Set up the full scale range to 2, 4, or 8g.\n    // FIXME: assumes HPF_OUT_BIT in this same register always == 0\n    writeReg(XYZ_DATA_CFG, maxG)\n    \n    // setup CTRL_REG1\n    reg = readReg(CTRL_REG1)\n    reg = writeBitField(reg, ASLP_RATE_BIT, 2, ASLP_RATE_1p56HZ)\n    reg = writeBitField(reg, DR_BIT, 3, DR_12p5HZ)\n    // leave LNOISE_BIT as default off to save power\n    // Set Fast read mode to read 8bits per xyz instead of 12bits\n    reg = writeBit(reg, F_READ_BIT, 1)\n    // set all CTRL_REG1 bit fields in one i2c write\n    writeReg(CTRL_REG1, reg)\n    \n    // setup CTRL_REG2\n    reg = readReg(CTRL_REG2)\n    // set Oversample mode in sleep\n    reg = writeBitField(reg, SMODS_BIT, 2, MODS_LOW_POWER)\n    // Enable Auto-SLEEP\n    //reg = writeBit(reg, SLPE_BIT, 1)\n    // Disable Auto-SLEEP\n    reg = writeBit(reg, SLPE_BIT, 0)\n    // set Oversample mode in wake\n    reg = writeBitField(reg, MODS_BIT, 2, MODS_LOW_POWER)\n    // set all CTRL_REG2 bit fields in one i2c write\n    writeReg(CTRL_REG2, reg)\n    \n    // setup CTRL_REG3\n    reg = readReg(CTRL_REG3)\n    // allow Motion to wake from SLEEP\n    reg = writeBit(reg, WAKE_FF_MT_BIT, 1)\n    // change Int Polarity\n    reg = writeBit(reg, IPOL_BIT, 1)\n    // set all CTRL_REG3 bit fields in one i2c write\n    writeReg(CTRL_REG3, reg)\n\n    // setup FF_MT_CFG\n    reg = readReg(FF_MT_CFG)\n    // enable ELE_BIT to latch FF_MT_SRC events\n    reg = writeBit(reg, ELE_BIT, 1)\n    // enable Motion detection (not Free Fall detection)\n    reg = writeBit(reg, OAE_BIT, 1)\n    // enable on all axis x, y, and z\n    reg = writeBitField(reg, XYZEFE_BIT, 3, XYZEFE_ALL)\n    // set all FF_MT_CFG bit fields in one i2c write\n    writeReg(FF_MT_CFG, reg)\n    log(format(\"FF_MT_CFG == 0x%02x\", readReg(FF_MT_CFG)), 150)\n    \n    // setup Motion threshold to n*0.063.  (16 * 0.063 == 1G)\n    writeReg(FF_MT_THS, 60) // FIXME: this is a shortcut and assumes DBCNTM_BIT is 0\n\n    // setup sleep counter, the time in multiples of 320ms of no activity to enter sleep mode\n    //dont' use ASLP_COUNT for now, use change in prev AccelData reading\n    //writeReg(ASLP_COUNT, 10) // 10 * 320ms = 3.2 seconds\n    \n    //Enable Sleep interrupts\n//    writeReg(CTRL_REG4, writeBit(readReg(CTRL_REG4), INT_EN_ASLP_BIT, 1))\n    //Enable Motion interrupts\n    writeReg(CTRL_REG4, writeBit(readReg(CTRL_REG4), INT_EN_FF_MT_BIT, 1))\n    // Enable interrupts on every new data\n    writeReg(CTRL_REG4, writeBit(readReg(CTRL_REG4), INT_EN_DRDY_BIT, 1))\n    log(format(\"CTRL_REG4 == 0x%02x\", readReg(CTRL_REG4)), 150)\n\n    MMA8452QSetActive(1)  // Set to active to start reading\n} // initMMA8452Q\n\n// now die specific functions\n\nfunction roll(dieValue) {\n    local t = timestamp() // FIXME: timestamp should come exactly when sample was captured\n    local tableDieEvent = {\n        \"impeeID\": impeeID,\n        \"roll\": dieValue,\n        \"t\": t,\n// can't use priority until proper UTC is used        \".priority\": t\n        }\n\n    // Agent will send this to http://interfacearts.webscript.io/electricdice appending \"?dieID=S10100000004&roll=6\" (example)\n//    log(impeeID + \" rolls a \" + dieValue, 120)\n    agent.send(\"dieEvent\", tableDieEvent)\n}\n\nfunction getFaceValueFromAccelData(xyz) {\n    local faceValue = \"s\"\n    local snapAngle = \"\"\n\n//<=-0.86    <=-.59    <=-0.25    <=0.26    <=.60	<=.87	<= 1.1\n//-1.00 	-0.707	     x	       0	    x	    0.707	1\n    foreach(val in xyz) {\n        if (val <= -875) {\n            snapAngle += \"a\"\n        } else if (val <= -550) {\n            snapAngle += \"b\"\n        } else if (val <= -150) {\n            snapAngle += \"x\"\n        } else if (val <= 150) {\n            snapAngle += \"0\"\n        } else if (val <= 550) {\n            snapAngle += \"x\"\n        } else if (val <= 875) {\n            snapAngle += \"c\"\n        } else {\n            snapAngle += \"d\"\n        }\n    }\n// facevalue	x	y	z           x*x + z*z\n//d1	0.000	1.000	0.000           0\n//d2	0.707	0.000	-0.707          1\n//d3	-0.707	0.000	-0.707          1\n//d4	0.707	0.000	0.707\n//d5	-0.707	0.000	0.707\n//d6	0.000	-1.000	0.000\n    // determine dice roll value (what side is up?)\n// try this method below instead? create xz axis by x*x + z*z \n    //    roll = \"x\";\n//    if (abs(inXYZ[1])<oneGAxis && abs(inXYZ[2])<oneGAxis && inXYZ[0] < xNegOneG)\n//      roll = \"3\";\n//    if (abs(inXYZ[1])<oneGAxis && abs(inXYZ[2])<oneGAxis && inXYZ[0] > xPosOneG)\n//      roll = \"4\";\n//    if (abs(inXYZ[0])<oneGAxis && abs(inXYZ[2])<oneGAxis && inXYZ[1] < yNegOneG)\n//      roll = \"1\";\n//    if (abs(inXYZ[0])<oneGAxis && abs(inXYZ[2])<oneGAxis && inXYZ[1] > yPosOneG)\n//      roll = \"6\";\n//    if (abs(inXYZ[0])<oneGAxis && abs(inXYZ[1])<oneGAxis && inXYZ[2] < zNegOneG)\n//      roll = \"5\";\n//    if (abs(inXYZ[0])<oneGAxis && abs(inXYZ[1])<oneGAxis && inXYZ[2] > zPosOneG)\n//      roll = \"2\";\n      \n    switch (snapAngle) {\n        case \"0d0\":\n            faceValue = \"1\"\n            break\n        case \"c0b\":\n            faceValue = \"2\"\n            break\n        case \"b0b\":\n            faceValue = \"3\"\n            break\n        case \"c0c\":\n            faceValue = \"4\"\n            break\n        case \"b0c\":\n            faceValue = \"5\"\n            break\n        case \"0a0\":\n            faceValue = \"6\"\n            break\n        default:\n            faceValue = \"x\"\n    }\n    return faceValue\n} // accelData2FaceValue\n\nfunction pollMMA8452Q() {\n    local xyz\n    local reg\n    local faceValue = lastFaceValue    \n\n    while (pollMMA8452QBusy) {\n        log(\"pollMMA8452QBusy collision\", 50)\n        // wait herer unitl other instance of int handler is done\n    }\n    pollMMA8452QBusy = true // mark as busy\n    if (hardware.pin1.read() == 1) { // only react to low to high edge\n//FIXME:  do we need to check status for data ready in all xyz?//log(format(\"STATUS == 0x%02x\", readReg(STATUS)), 80)\n        reg = readReg(INT_SOURCE)\n        while (reg != 0x00) {\n//            log(format(\"INT_SOURCE == 0x%02x\", reg), 200)\n            if (readBit(reg, SRC_DRDY_BIT) == 0x1) {\n                xyz = readAccelData() // this clears the SRC_DRDY_BIT\n                log(format(\"%4d %4d %4d\", xyz[0], xyz[1], xyz[2]), 200)\n                faceValue = getFaceValueFromAccelData(xyz)\n                if (faceValue != lastFaceValue) {\n                    roll(faceValue)\n                    lastFaceValue = faceValue\n                    imp.setpowersave(false) // go to low latency mode when facevalue changes\n                }\n            }\n            if (readBit(reg, SRC_FF_MT_BIT) == 0x1) {\n                log(\"Interrupt SRC_FF_MT_BIT\", 50)\n                reg = readReg(FF_MT_SRC) // this clears SRC_FF_MT_BIT\n                imp.setpowersave(false) // go to low latency mode because we detected motion\n            }\n            if (readBit(reg, SRC_ASLP_BIT) == 0x1) {\n                reg = readReg(SYSMOD) // this clears SRC_ASLP_BIT\n//                log(format(\"Entering SYSMOD 0x%02x\", reg), 100)\n            }\n            reg = readReg(INT_SOURCE)\n        } // while (reg != 0x00)\n    } else {\n//        log(\"INT2 LOW\", 200)\n    }\n    pollMMA8452QBusy = false // clear so other inst of int handler can run\n} // pollMMA8452Q\n\nfunction getVBatt() {\n    local tableVBatt = {\n        \"min\": 10,\n        \"max\": 0,\n        \"avg\": 0,\n        \"hardware-voltage\": hardware.voltage(),\n        \"count\": 3\n    }\n    local i = tableVBatt.count\n    local voltage = 0\n    \n    vBatt.read() \n    // read count times and save min, max, and average\n    while (i--){\n        voltage = (2 * vBatt.read() / 65535.0) * hardware.voltage()\n        if (voltage < tableVBatt.min) { tableVBatt.min = voltage }\n        if (voltage > tableVBatt.max) { tableVBatt.max = voltage }\n        tableVBatt.avg = tableVBatt.avg + voltage\n    }\n    tableVBatt.avg = tableVBatt.avg / tableVBatt.count\n    return tableVBatt\n}\n\n////////////////////////////////////////////////////////\n// first code starts here\n\nimp.setpowersave(true) // start in low power mode.\n    // Optimized for case where wakeup was caused by periodic timer, not user activity\n\n// Register with the server\n//imp.configure(\"MMA8452Q 1D6\", [], []) // One 6-sided Die\n// no in and out []s anymore, using Agent messages\n\n// Send status to know we are alive\nlog(\"BOOTING  \" + versionString + \" \" + hardware.getimpeeid() + \"/\" + imp.getmacaddress(), 0)\n\n// roll every time we boot just for some debug status\nroll(\"boot0\")\n\n// BUGBUG: below needed until newer firmware!?  See http://forums.electricimp.com/discussion/comment/4875#Comment_2714\nimp.enableblinkup(true)\n\nlocal lastUTCSeconds = time()\nwhile(lastUTCSeconds == time()) {\n}\noffsetMilliseconds = hardware.millis() % 1000\nlog(\"offsetMilliseconds = \" + offsetMilliseconds, 30)\nlog(format(\"lastUTCSeconds = %013u\", lastUTCSeconds), 40)\n//log(format(\"lastUTCSeconds = %013u\", lastUTCSeconds * 1000.0), 40)\n\nlog(\"powersave = \" + imp.getpowersave(), 100)\n// Configure pin1 for wakeup.  Connect MMA8452Q INT2 pin to imp pin1.\nhardware.pin1.configure(DIGITAL_IN_WAKEUP, pollMMA8452Q)\n// Configure pin5 as ADC to read Vbatt/2.0\nvBatt.configure(ANALOG_IN)\n// set the I2C clock speed. We can do 10 kHz, 50 kHz, 100 kHz, or 400 kHz\ni2c.configure(CLOCK_SPEED_400_KHZ)\ninitMMA8452Q()  // sets up code to run on interrupts from MMA8452Q\n\ncheckActivity() // kickstart checkActivity, this re-schedules itself every sleepforTimeout seconds\n// FIXME: checkActivity waits from sleepforTimeout to sleepforTimeout*2.  Make this more constant.\n\npollMMA8452Q()  // call first time to get a roll value on boot.\n\n// No more code to execute so we'll sleep until an interrupt from MMA8452Q.\n// End of code.\n// Electric Dice using MMA8452Q accelerometer */\n// ThingApp Imp Device Squirrel code */",
			"file": "ThingApp_Imp_Dice_MMA8452Q_Device.nut",
			"file_size": 21669,
			"file_write_time": 130123620843304804,
			"settings":
			{
				"buffer_size": 21135,
				"line_ending": "Windows"
			}
		},
		{
			"file": "CloudApp_Imp_Dice_MMA8452Q.Agent..nut",
			"settings":
			{
				"buffer_size": 4101,
				"line_ending": "Windows"
			}
		},
		{
			"file": "CloudApp_Imp_Dice_rules.json",
			"settings":
			{
				"buffer_size": 1443,
				"line_ending": "Windows"
			}
		},
		{
			"file": "electricdice-all-metadata-export.json",
			"settings":
			{
				"buffer_size": 7362,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 392.0,
		"selected_items":
		[
		],
		"width": 392.0
	},
	"console":
	{
		"height": 146.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": true,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/C/Users/duppy/Dropbox/Apps/site44/www.interfacearts.com/fireview/index.html",
		"/C/Users/duppy/Dropbox/Apps/site44/www.interfacearts.com/index.html",
		"/C/Users/duppy/Dropbox/Apps/site44/fireview.interfacearts.com/index (Duppy Proctor's conflicted copy 2013-05-03).html",
		"/C/Users/duppy/Dropbox/TechShop/Cloud Dice/WebApp/ElectricDice_WebApp_Demo/d3.js.index.html",
		"/C/Users/duppy/Dropbox/TechShop/CoCo/TIworkspace/CoCo-ThingApp-DVT/CoCo BlueGiga/CoCo.bgs",
		"/C/Users/duppy/Dropbox/TechShop/Cloud Dice/WebApp/ElectricDice_WebApp_Demo/electricdice-fb-d3.js",
		"/C/Users/duppy/Documents/GitHub/senstream-firmware/mobilemuse_arduino/mobilemuse_arduino.ino",
		"/C/Users/duppy/AppData/Roaming/Sublime Text 2/Packages/User/Preferences.sublime-settings",
		"/C/Users/duppy/AppData/Roaming/Sublime Text 2/Packages/Squirrel/Squirrel.tmLanguage",
		"/C/Users/duppy/Dropbox/TechShop/Cloud Dice/ThingApp/ElectricDice-ThingApp-Proxy-Processing/ElectricDice_ThingApp/ElectricImp_Dice/CloudApp_Imp_Dice_MMA8452Q.Agent..nut",
		"/C/Users/duppy/Dropbox/TechShop/Cloud Dice/ThingApp/ElectricDice-ThingApp-Proxy-Processing/ElectricDice_ThingApp/ElectricImp_Dice/ThingApp_Imp_Dice_MMA8452Q_Device.nut",
		"/C/Users/duppy/AppData/Roaming/Sublime Text 2/Packages/User/Plain text.sublime-settings",
		"/C/Users/duppy/AppData/Roaming/Sublime Text 2/Packages/Default/Preferences.sublime-settings",
		"/C/Users/duppy/Dropbox/TechShop/Cloud Dice/WebApp/ElectricDice_WebApp_Demo/ex-bootstratp.html"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"offsetMilliseconds",
			"estimate",
			"estimatedUTCMilliseconds",
			"es",
			"estimatedUTCMilliseconds",
			"local",
			"data-by-session",
			": {: {",
			": {",
			"\" :",
			"maxG",
			"fullScale"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "ThingApp_Imp_Dice_MMA8452Q_Device.nut",
					"settings":
					{
						"buffer_size": 21135,
						"regions":
						{
						},
						"selection":
						[
							[
								753,
								753
							]
						],
						"settings":
						{
							"rulers":
							[
								80
							],
							"syntax": "Packages/Squirrel/Squirrel.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true,
							"word_wrap": true,
							"wrap_width": 80
						},
						"translation.x": 0.0,
						"translation.y": 10733.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "CloudApp_Imp_Dice_MMA8452Q.Agent..nut",
					"settings":
					{
						"buffer_size": 4101,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Squirrel/Squirrel.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "CloudApp_Imp_Dice_rules.json",
					"settings":
					{
						"buffer_size": 1443,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JSON.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "electricdice-all-metadata-export.json",
					"settings":
					{
						"buffer_size": 7362,
						"regions":
						{
						},
						"selection":
						[
							[
								5216,
								5231
							]
						],
						"settings":
						{
							"rulers":
							[
								80
							],
							"syntax": "Packages/JavaScript/JSON.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true,
							"word_wrap": true,
							"wrap_width": 80
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.unsaved_changes":
	{
		"height": 404.0
	},
	"replace":
	{
		"height": 0.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"selected_items":
		[
			[
				"",
				"/C/Users/duppy/Documents/GitHub/senstream-firmware/Schematics/schematics-senstream.sublime-project"
			]
		],
		"width": 380.0
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": false,
	"side_bar_width": 150.0,
	"status_bar_visible": true
}
